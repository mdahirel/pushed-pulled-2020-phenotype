---
title: "Supplementary Material for: \"Landscape connectivity alters the evolution of density-dependent dispersal during pushed range expansions\" "
author: "Maxime Dahirel, Aline Bertin, Vincent Calcagno, Camille Duraj, Simon Fellous, Géraldine Groussier, Ludovic Mailleret, Anaël Marchand, Elodie Vercken"
date:
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-packages}
library(arm)
library(tidyverse)

library(cmdstanr) 
#library(rstan) 
#rstan can be used as alternate backend; just don't forget to change the backend argument in each model
library(brms)
options(mc.cores = 2)

library(bayesplot)

library(tidybayes)

library(patchwork)

library(here)
```

# S.1 - model descriptions

# S.2 - pairwise plots (+ goodness of fits plots? + r2?)
 
```{r load-raw-data}

raw_dynamics <- read_csv(here("data","expansion_data","Trichogramma_dynamics.csv"))

raw_size <- read_csv(here("data","exp1_bodysize.csv"))

raw_mvt <- read_csv(here("data","exp2_movement.csv"))

raw_fec <- read_csv(here("data","exp2_fecundity.csv"))
raw_disp <- read_csv(here("data","exp2_dispersal.csv"))

raw_fec_dens <- read_csv(here("data","exp3_fecundity.csv"))
raw_disp_dens <- read_csv(here("data","exp3_dispersal.csv"))
```

```{r}

preds_size <- data_size %>% 
  select(context,Location,Treatment) %>% 
  mutate(Treatment=fct_relevel(factor(Treatment),"stock",after=0)) %>% 
  unique() %>% 
  add_fitted_draws(mod_size,re_formula = NA) %>% 
  ungroup() %>% 
  mutate(.value=.value* (sd(data_size$tibia,na.rm=TRUE))+ (mean(data_size$tibia,na.rm=TRUE))) %>% 
  select(.draw,.value,Treatment,Location,context)


##no differences among treatments
preds_size %>%  
  compare_levels(.value,by=context) %>% 
  ggplot()+
  stat_eye(aes(y=context,x=.value), .width=c(0.01,0.95))+
  geom_vline(xintercept = 0) +
  theme_bw()

preds_mvt <- data_mvt %>% 
  select(context,Location,Treatment) %>% 
  mutate(Treatment=fct_relevel(factor(Treatment),"stock",after=0)) %>% 
  distinct() %>% 
  add_fitted_draws(mod_mvt,re_formula = NA) %>% 
  ungroup()

##no differences among treatments
preds_mvt %>%  
  compare_levels(.value,by=context) %>% 
  ggplot()+
  stat_eye(aes(y=context,x=.value), .width=c(0.01,0.95))+
  geom_vline(xintercept = 0) +
  theme_bw()

data_fec %>% 
  select(Location, Treatment, context) %>% 
  distinct() %>% 
  add_fitted_draws(mod_fec,re_formula=NA) %>% 
  ungroup() %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  select(Location, Treatment, context, .draw, .value) %>% 
  compare_levels(.value, by = context) %>% 
  mean_hdi()

data_fec_dens %>%  
  select(Location, Treatment, context, Density, Density_centred) %>% 
  distinct() %>% 
  add_fitted_draws(mod_fec_dens,re_formula=NA) %>%
  ungroup() %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  select(Location, Treatment, context, Density, .draw, .value) %>% 
  group_by(Density) %>% 
  compare_levels(.value, by = context) %>% 
  mean_hdi()

data_disp_dens %>%  
  mutate(Neggs_all_scaled = mean(Neggs_all_scaled),
         Neggs_all = 1) %>% 
  select(Location, Treatment, context, Neggs_all_scaled, Neggs_all, Density, Density_centred) %>% 
  distinct() %>% 
  add_fitted_draws(mod_disp_dens,re_formula=NA) %>% 
  ungroup() %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  select(Location, Treatment, context, Density, .draw, .value) %>% 
  group_by(Density) %>% 
  compare_levels(.value, by = context) %>% 
  mean_hdi()

data_disp %>%  
  mutate(Neggs_all_scaled = mean(Neggs_all_scaled),
         Neggs_all = 1) %>% 
  select(Location, Treatment, context, Neggs_all_scaled, Neggs_all) %>% 
  distinct() %>% 
  add_fitted_draws(mod_disp,re_formula=NA) %>% 
  ungroup() %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  select(Location, Treatment, context, .draw, .value) %>% 
  compare_levels(.value, by = context) %>% 
  mean_hdi()
```

# S.3 - Effect of experimental connectivity level on demographic variability

In the main text, we mention that levels of environmental variability may influence the slope of the density-dispersal relationship, based on Rodrigues & Johnstone [-@rodrigues2014], and that it *may* explain how core patches from landscapes with different connectivity differ in dispersal dynamics in unexpected ways. To validate this, we need to show that experimental treatment has an effect on environmental variability in core patches. In our case, this is equivalent to looking at demographic variability (because resources \_hosts\_ are fixed, so the amount of resource per individual is only driven by the number of individuals). We do have access to population size estimates for this experiment. These data are re-used from [@dahirel2020], we invite the reader to look at the original source for details about the raw data characteristics. The processed dataset contains information about mean population size (proportion of hosts parasitised), SD and coefficient of variation CV for each experimental landscape. Because population size were estimated semi-automatically using four differently-biased computer macros that roughly compensate each other [again, see @dahirel2020], we have four values per landscape, one per macro/"observer".

```{r data-processing-cv}
data_cv <- raw_dynamics %>% 
  mutate(Mix= as.numeric(str_sub(Image,1,1)),
         Treatment = str_sub(Image,2,3),
         Replicate = as.numeric(str_sub(Image,4,4)),
         Patch = as.numeric(str_sub(Image,6,7))
  ) %>% 
  #no further processing needed; we exploit the fact that chars 6&7 are either digit dot (patchs 0 to 9)
#or digit-digit (patches 10 and beyond)
## as.numeric() resolves both correctly (e.g; "2." and "12" become 2 and 12)
  filter(Patch==0) %>% #we only keep the core patch for this analysis
  mutate(landscapeID=paste("Mix",Mix,"_Treatment",Treatment,"_Replicate",Replicate,sep="")) %>% #a unique replicate ID
  mutate(Peggs_est=P/(P+H), ## proportion of pixels counted as parasitised (estimated)
         Mix = factor(Mix)) %>% 
  mutate(Treatment = fct_recode(Treatment,`reference`="PL",`reduced connectivity`="PS")) %>% 
  group_by(Treatment,landscapeID,Macro,Mix) %>% 
  summarise(meanP=mean(Peggs_est,na.rm=TRUE),sdP=sd(Peggs_est,na.rm=TRUE)) %>% 
  mutate(CV_P=sdP/meanP) %>% 
  ungroup()
```

We analyse coefficients of variation using a lognormal mixed model:

$$
\mathrm{CV}_{i,j,m} \sim \mathrm{LogNormal}(\mu_{i,j,m}, \sigma_{d}), \\
\mu_{i,j,m} = \beta_{0} + \beta_1 \times x_{i} + \alpha_{j} + \gamma_{m}, \\
\alpha_{j} \sim \mathrm{Normal}(0, \sigma_{\alpha}), \\
\gamma_{m} \sim \mathrm{Normal}(0, \sigma_{\gamma}), \\
$$

where the $CV_{i,j,m}$ of replicate $i$ from genetic mix $j$ as seen by macro $m$ depends on its connectivity level and on random effects of mix and macro. We use $\mathrm{Normal}(0,1)$ priors for fixed effects and $\mathrm{halfNormal}(0,1)$ for all $\sigma$ (random effects and residuals).

```{r model-cv}
if (file.exists(here("R_output", "model_suppl_CV.Rdata"))){
    load(here("R_output", "model_suppl_CV.Rdata"))
  } else {
mod_cv <- brm(CV_P ~ Treatment + (1|Macro) + (1|Mix),
        family=lognormal,
        data=data_cv,
        prior=c(
          set_prior("normal(0,1)",class="b"),
          set_prior("normal(0,1)",class="sd"),
          set_prior("normal(0,1)",class="sigma")
        ), 
        control=list(adapt_delta=0.99, max_treedepth=20),
        
        chains=4, iter=4000, warmup = 2000, seed=42, backend="cmdstanr"
        )

  save(list = "mod_cv", file = here("R_output", "model_suppl_CV.Rdata"))
  }

ratio_cv <- posterior_samples(mod_cv) %>% select("b_Treatmentreducedconnectivity") %>% exp() %>% mean_hdi()
```

We find that core patches were less demographically variable when connectivity was reduced, with a CV on average `r ratio_cv$b_Treatmentreducedconnectivity` [`r ratio_cv$.lower`, `r ratio_cv$.upper`] times the one of reference patches (**Fig. S.3-1**).

```{r fig-cv}
data_cv %>% 
  select(Treatment) %>% 
  distinct() %>% 
  add_fitted_draws(mod_cv,re_formula=NA) %>% 
  ungroup() %>% 
  ggplot() +
  geom_jitter(data=data_cv %>% 
                group_by(Treatment,landscapeID) %>%
                summarise(CV_P=mean(CV_P)), # each point = one pop (average of the four macros/observers)
              aes(x=Treatment,y=CV_P),col="grey50",alpha=0.4,size=2)+
  stat_eye(aes(x=Treatment,y=.value), .width=c(0.01,0.95), slab_alpha=0.7)+
  scale_x_discrete("Connectivity treatment")+
  scale_y_continuous("Core patch (x = 0) population size CV during range expansion")+
  coord_cartesian(ylim=c(0,1.5))+
  theme_bw()
```

**Figure S.3-1** - Posterior predicted demographic variability (Population size coefficient of variation) in core patches ($x = 0$) as a function of connectivity treatment. Black dots and segments are posterior means and 95% credible intervals, gray dots are observed values (averaged across "observer" macros).
