---
title: "Code for: \"Landscape connectivity alters the evolution of density-dependent dispersal during pushed range expansions\" "
author: "Maxime Dahirel, Aline Bertin, Vincent Calcagno, Camille Duraj, Simon Fellous, Géraldine Groussier, Eric Lombaert, Ludovic Mailleret, Anaël Marchand, Elodie Vercken (this code by M. Dahirel)"
date:
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
library(arm) # for the out of the box logit() functions
library(tidyverse)

library(cmdstanr) 
#library(rstan) 
#rstan can be used as alternate backend; just don't forget to change the backend argument in each model
library(brms)
options(mc.cores = 4) # for the number of chains running in parallel (reduce if needed, models will just take longer to run)

library(bayesplot)

library(tidybayes)

library(ggnewscale)
library(patchwork)

library(here)
```

# Introduction

## Aims of project 

To understand how connectivity (previously shown to influence the position of a range expansion on a pushed/pulled gradient) influences phenotypic evolution during experimental range expansion in *Trichogramma brassicae* wasps

## General methods (see preprint or article for full details)

24 experimental linear landscapes were created, consisting in patches/vials connected by tubes. Half the landscapes were low connectivity, the other half reference connectivity. 

*Trichogramma brassicae* individuals were introduced in the initial patch, and the expansion experiment ran for 14 generations, counting the starting and final individuals. There were three independent source populations/strains/genetic mixes; each was used to start 8 landscapes.

Towards the end of the experiments, individuals at the core and edge of several of these expansions were sampled, and either measured (size data) or placed in a common garden setting for further experiments (movement, fecundity and dispersal data). They were also compared to individuals from the original stock/source populations. Experiments on dispersal and fecundity were done twice, once on the F1 with no density-dependence, once on the F2 with individuals split in low-density and high-density development contexts.

# Analysis

## Loading datasets

(the number *X* in the "expX_trait.csv" refers to the generation of the experiment. 1: directly taken from the expanding landscapes; 2: one generation of common garden; 3: two generation of common garden)

```{r load-datasets}

raw_size <- read_csv(here("data","exp1_bodysize.csv"))

raw_mvt <- read_csv(here("data","exp2_movement.csv"))

raw_fec <- read_csv(here("data","exp2_fecundity.csv"))
raw_disp <- read_csv(here("data","exp2_dispersal.csv"))

raw_fec_dens <- read_csv(here("data","exp3_fecundity.csv"))
raw_disp_dens <- read_csv(here("data","exp3_dispersal.csv"))
```

All 6 datasets share the following columns:

- `Generation`: the generation *from the expanding landscapes* the individuals are sourced from (0 if individuals come from the stock)

- `Mix`: the name of the source strain

- `Treatment`: the connectivity level of the source landscape ("stock" if individuals come from the stock)

- `Location`: "stock", "core" or "front" (edge)

- `Replicate`: a replicate landscape ID. Only designate a unique landscape when combine with `Mix` and `Treatment`

Columns specific to one dataset are detailed in the relevant paragraph below.

## Body size

The `raw_size` dataset contains the additional columns:

- `Patch`: which patch was sampled, expressed as distance from the release patch

- `ID_in_batch`: individual ID within a batch of pictures (a batch containing pictures from the same `Mix`, `Treatment`,`Location`, `Replicate`, so all these columns are needed to get an actual individual-level unique ID)

- `imageID`: name of the source photograph

- `tibia_obsC` and `tibia_obsA`: tibia lengths (in micrometers) as measures by observers "C" (co-author CD) and "A" (co-author AM), respectively. The correlation between the two is good (>0.9) but not perfect (see below). So we'll use a hierarchical approach to account for observer error.

```{r size-observer-correl}
cor.test(raw_size$tibia_obsA,raw_size$tibia_obsC)
```


Before we can use this dataset for modelling, we need the following steps:

- obtain actually unique IDs for replicate landscape (`IDgroup`), populations (`IDpop`) and individuals (`IDindiv`). Stock populations count as their own replicate landscape and population

- recoding Treatment and Location levels with more accurate names for plotting

- combine `Treatment` and `Location` in a common `context` variable for modelling

- pivoting size data to a long format, so one row = one observation instead of one row = one individual with obs by different observers on different columns: 

```{r size-data-cleaning}
data_size<-raw_size %>%
                mutate(IDgroup=ifelse(Generation==0,
                                      paste("Mix",Mix,"_stock",sep=""),
                                      paste("Mix",Mix,"_",Treatment,"_Rep",Replicate,"_GenerationFinal",sep="")
                                      )
                       )%>% 
                mutate(Location=fct_recode(factor(Location),edge="front")) %>% 
                mutate(Treatment=fct_recode(factor(Treatment),
                                            reference="control",
                                            `reduced connectivity`="restricted connectedness")) %>% 
                mutate(IDpop=ifelse(Generation==0,
                                    IDgroup,
                                    paste(IDgroup,"_Location",Location,sep=""))) %>% 
                mutate(IDindiv=paste(IDpop,ID_in_batch,sep="_")) %>% 
                mutate(context=paste(Treatment,Location)) %>% 
                mutate(context=fct_recode(context,stock="stock stock")) %>% 
                mutate(context = fct_relevel(context,"stock", after=0)) %>%
                pivot_longer(cols=c("tibia_obsA","tibia_obsC"),names_to="observer",values_to="tibia") %>% 
  filter(is.na(tibia)==FALSE)

```

We can now fit our model (note the use of nested hierarchical groups to reflect phylogenetic relationships among subgroups): 

```{r model-size}
if (file.exists(here("R_output", "model_size.Rdata"))){
# this if-else statement is avoid re-fitting a model if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
    load(here("R_output", "model_size.Rdata"))
  } else {

mod_size <- brm(bf(scale(tibia)~context+(1|Mix/IDgroup/IDpop)+(1|IDindiv)),
        data=data_size,
        chains=4,iter=4000,
        prior=c(set_prior("normal(0,1)",class="Intercept"),
                set_prior("normal(0,1)",class="b"),
                set_prior("normal(0,1)",class="sigma"),
                set_prior("normal(0,1)",class="sd")),
        seed=42,control=list(adapt_delta=0.99,max_treedepth=15), backend="cmdstanr"
)

  save(list = "mod_size", file = here("R_output", "model_size.Rdata"))
}
```

We can check that the model is adequate for the data in many ways (see the help and functions in `bayesplot`). Let's look at whether the model predicts well individual points. Because the model includes individual-level effects, we should expect it to be *very* good at its job unless between-observer error is very weird and/or large:

```{r summary-model}
###prediction intervals around each point
ppc_ribbon(yrep=(predict(mod_size,summary=FALSE)),
           x=rank(predict(mod_size)[,1]),
           y=scale(data_size$tibia)[,1],
           prob = 0.5, prob_outer=0.95)
```

We can move on to the next data (plots will be drawn later).

## Short-term movement

The `raw_mvt` dataset contains the additional columns:

- `File`: name of the source file

```{r}
data_mvt<-raw_mvt %>% 
                filter(Generation %in% c(0,10)) %>% 
                filter(timestamp<=300) %>% ##some replicate are filmed slightly longer than the nominal 5 minutes, this removes their ends to standardize
                mutate(IDgroup=ifelse(Generation==0,
                                      paste("Mix",Mix,"_stock",sep=""),
                                      paste("Mix",Mix,"_",Treatment,"_Rep",Replicate,"_Generation10",sep="")
                                      )
                       )%>% 
                mutate(Location=fct_recode(factor(Location),edge="front")) %>% 
                mutate(Treatment=fct_recode(factor(Treatment),
                                            reference="control",
                                            `reduced connectivity`="restricted connectedness")) %>% 
                mutate(IDpop=ifelse(Generation==0,
                                    IDgroup,
                                    paste(IDgroup,"_Location",Location,sep=""))) %>% 
                mutate(IDtest=paste(IDpop,testing_unit,sep="_")) %>% 
                mutate(context=paste(Treatment,Location)) %>% 
                mutate(context=fct_recode(context,stock="stock stock")) %>% 
                mutate(context = fct_relevel(context,"stock", after=0)) %>%
                group_by(Mix,Treatment,Generation,Replicate,Location,IDgroup,IDpop,IDtest,context) %>% 
                summarise(percentData=mean(percentData), ##this column is already a testing_unit- level variable
                          activity_time=sum(path_duration*activity_percent),
                          obs_time=sum(path_duration),
                          sinuosity=weighted.mean(sinuosity,path_duration,na.rm=TRUE),
                          mean_speed2=mean(path_length/path_duration,na.rm=TRUE),
                          dist_total=sum(path_length,na.rm=TRUE)
                          ) %>% 
                mutate(activity_percent=activity_time/obs_time,
                       mean_speed1=dist_total/obs_time) %>% 
  ungroup()
```


```{r}
if (file.exists(here("R_output", "model_mvt.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_mvt.Rdata"))
  } else {
mod_mvt=brm(bf(activity_percent~context+(1|Mix/IDgroup/IDpop),
               nlf(phi~1/invphi),
               invphi~1),
        data=data_mvt,family=Beta,
        chains=4,iter=6000,
        prior=c(set_prior("normal(0,1.5)",class="Intercept"),
                set_prior("normal(0,1)",class="b"),
                set_prior("normal(0,1)",class="sd"),
                set_prior("normal(0,1)",nlpar="invphi",lb=0)),
        seed=42,control=list(adapt_delta=0.99),backend="cmdstanr"
)
  save(list = "mod_mvt", file = here("R_output", "model_mvt.Rdata"))
  }

### to do: model with speed???
```


```{r}
preds_mvt <- data_mvt %>% 
  select(context,Location,Treatment) %>% 
  mutate(Treatment=fct_relevel(factor(Treatment),"stock",after=0)) %>% 
  distinct() %>% 
  add_fitted_draws(mod_mvt,re_formula = NA) %>% 
  ungroup()

ggplot(preds_mvt) +
  geom_jitter(data=data_mvt,aes(x=Location,y=activity_percent, size=obs_time),col="grey50",alpha=0.4)+
  scale_size(range=c(1,4), guide=FALSE)+
  ggnewscale::new_scale("size")+
  stat_eye(aes(x=Location,y=.value), .width=c(0.01,0.95), slab_alpha=0.7)+
  scale_x_discrete("Experimental context")+
  scale_y_continuous("Proportion of time active")+
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  theme_bw()

#posterior grand mean
preds_mvt %>% 
  group_by(.draw) %>% 
  summarise(grandmean=mean(.value)) %>% 
  mean_hdi(grandmean)

```


# Fecundity 1

```{r}
data_fec<-raw_fec %>% 
                filter(Generation %in% c(0,12)) %>%
                mutate(IDgroup=ifelse(Generation==0,
                                      paste("Mix",Mix,"_stock",sep=""),
                                      paste("Mix",Mix,"_",Treatment,"_Rep",Replicate,"_GenerationFinal",sep="")
                                      )
                       )%>% 
                mutate(Location=fct_recode(factor(Location),edge="front")) %>% 
                mutate(Treatment=fct_recode(factor(Treatment),
                                            reference="control",
                                            `reduced connectivity`="restricted connectedness")) %>%
                mutate(IDpop=ifelse(Generation==0,
                                    IDgroup,
                                    paste(IDgroup,"_Location",Location,sep=""))) %>% 
                mutate(context=paste(Treatment,Location)) %>% 
                mutate(context=fct_recode(context,stock="stock stock"))%>%
                mutate(context = fct_relevel(context,"stock", after=0)) 

data_fec$obsID=1:dim(data_fec)[1]
```


```{r}
if (file.exists(here("R_output", "model_fecundity1.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_fecundity1.Rdata"))
  } else {
mod_fec=brm(bf(Fecundity~context+(1|Mix/IDgroup/IDpop),
            zi~context+(1|Mix/IDgroup/IDpop),
            nlf(shape~1/invshape),
               invshape~1),
         data=data_fec,family=zero_inflated_negbinomial(),
         chains=4,iter=4000,
         prior=c(set_prior("normal(3.8,0.5)",class="Intercept"),
                 set_prior("normal(0,1)",class="b"),
                 set_prior("normal(0,1)",class="sd"),
                 set_prior("normal(0,0.2)",class="sd",group="Mix"), ## narrower prior for mix to stamp divergences
                 set_prior("normal(0,1.5)",class="Intercept",dpar="zi"),
                 set_prior("normal(0,1)",class="b",dpar="zi"),
                 set_prior("normal(0,1)",class="sd",dpar="zi"),
                 set_prior("normal(0,0.2)",class="sd",dpar="zi",group="Mix"),
                set_prior("normal(0,1)",nlpar="invshape",lb=0)),
         seed=42,control=list(adapt_delta=0.99,max_treedepth=20),backend="cmdstanr"
)

  save(list = "mod_fec", file = here("R_output", "model_fecundity1.Rdata"))
  }

```




# Fecundity 2
```{r}
data_fec_dens<-raw_fec_dens %>% 
                mutate(IDgroup=ifelse(Generation==0,
                                      paste("Mix",Mix,"_stock",sep=""),
                                      paste("Mix",Mix,"_",Treatment,"_Rep",Replicate,"_GenerationFinal",sep="")
                                      )
                       )%>% 
                mutate(Location=fct_recode(factor(Location),edge="front")) %>% 
                mutate(Treatment=fct_recode(factor(Treatment),
                                            reference="control",
                                            `reduced connectivity`="restricted connectedness")) %>%
                mutate(IDpop=ifelse(Generation==0,
                                    IDgroup,
                                    paste(IDgroup,"_Location",Location,sep=""))) %>% 
                mutate(context=paste(Treatment,Location)) %>% 
                mutate(context=fct_recode(context,stock="stock stock"))%>% 
                mutate(context = fct_relevel(context,"stock", after=0)) %>% 
                mutate(Density=fct_relevel(factor(Density),"high",after=Inf)) %>% 
                mutate(Density_centred = as.numeric(Density=="high") - mean(as.numeric(Density=="high")))

data_fec_dens$obsID=1:dim(data_fec_dens)[1]
```

```{r}
if (file.exists(here("R_output", "model_fecundity2.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_fecundity2.Rdata"))
  } else {
mod_fec_dens=brm(bf(Fecundity~context*Density_centred+(1|Mix/IDgroup/IDpop),
            zi~context*Density_centred+(1|Mix/IDgroup/IDpop),
            nlf(shape~1/invshape),
               invshape~1),
         data=data_fec_dens,family=zero_inflated_negbinomial,
         chains=4,iter=4000,
         prior=c(set_prior("normal(3.8,0.5)",class="Intercept"),
                 set_prior("normal(0,1)",class="b"),
                 set_prior("normal(0,1)",class="sd"),
                 set_prior("normal(0,0.2)",class="sd",group="Mix"), ## narrower prior for mix to stamp divergences
                 set_prior("normal(0,1.5)",class="Intercept",dpar="zi"),
                 set_prior("normal(0,1)",class="b",dpar="zi"),
                 set_prior("normal(0,1)",class="sd",dpar="zi"),
                 set_prior("normal(0,0.2)",class="sd",dpar="zi",group="Mix"),
                set_prior("normal(0,1)",nlpar="invshape",lb=0)),
         seed=42,control=list(adapt_delta=0.99,max_treedepth=20),backend="cmdstanr"
)
  save(list = "mod_fec_dens", file = here("R_output", "model_fecundity2.Rdata"))
}
```



```{r summary-model}
###prediction intervals around each point
ppc_ribbon(yrep=(predict(mod_fec_dens,summary=FALSE)),
           x=rank(predict(mod_fec_dens)[,1]),
           y=data_fec_dens$Fecundity,
           prob = 0.5, prob_outer=0.95)
```

```{r}

p1 <- data_fec %>% 
  select(Location, Treatment, context) %>% 
  distinct() %>% 
  add_fitted_draws(mod_fec,re_formula=NA) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  ggplot()+
  geom_jitter(data=data_fec,
              aes(Location,Fecundity),
              col="#d95f02",alpha=0.4)+
  stat_eye(aes(Location, .value),.width=c(0.01,0.95),fill="#d95f02", slab_alpha=0.7)+
  scale_x_discrete("")+
  scale_y_continuous("# of hosts parasitised")+
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  coord_cartesian(ylim=c(0,90))+
  theme_bw()

p2 <- data_fec_dens %>%  
  select(Location, Treatment, context, Density, Density_centred) %>% 
  distinct() %>% 
  add_fitted_draws(mod_fec_dens,re_formula=NA) %>%
  ungroup() %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  ggplot()+
  geom_point(data=data_fec_dens,
             aes(Location,Fecundity, col=Density),
             position=position_jitterdodge(dodge.width=1), alpha=0.4)+
  stat_eye(aes(Location, .value,fill=Density), .width=c(0.01,0.95), position="dodge", slab_alpha=0.7)+
  scale_x_discrete("")+
  scale_y_continuous("# of hosts parasitised")+
  scale_fill_manual(values=c("#d95f02","#7570b3")) + 
  scale_colour_manual(values=c("#d95f02","#7570b3")) + 
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  coord_cartesian(ylim=c(0,90))+
  theme_bw()+
  guides(size = FALSE)

p3 <- data_fec_dens %>%  
  select(Location, Treatment, context, Density, Density_centred) %>% 
  distinct() %>% 
  add_fitted_draws(mod_fec_dens,re_formula=NA) %>%
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  ungroup() %>% 
  select(Location, Treatment, Density, .value, .draw) %>% 
  pivot_wider(names_from=Density,values_from=.value) %>% 
  mutate(diff=log(high)-log(low)) %>% 
  ggplot()+
  stat_eye(aes(Location, diff), .width=c(0.01,0.95),slab_alpha=0.7)+
  geom_hline(yintercept=0,lty=2)+
  scale_x_discrete("Experimental context")+
  scale_y_continuous("Net effect of density (log scale)")+
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  coord_cartesian(ylim=c(-1,1))+
  theme_bw()

(p1/p2/p3) & plot_annotation(tag_levels = "A")

```


# Dispersal 1
```{r}
data_disp<-raw_disp %>% 
                filter(Generation %in% c(0,12)) %>%
                mutate(IDgroup=ifelse(Generation==0,
                                      paste("Mix",Mix,"_stock",sep=""),
                                      paste("Mix",Mix,"_",Treatment,"_Rep",Replicate,"_GenerationFinal",sep="")
                                      )
                       )%>% 
                mutate(Location=fct_recode(factor(Location),edge="front")) %>% 
                mutate(Treatment=fct_recode(factor(Treatment),
                                            reference="control",
                                            `reduced connectivity`="restricted connectedness")) %>%
                mutate(IDpop=ifelse(Generation==0,
                                    IDgroup,
                                    paste(IDgroup,"_Location",Location,sep=""))) %>% 
                mutate(context=paste(Treatment,Location)) %>% 
                mutate(context=relevel(factor(context),"stock stock")) %>%
                mutate(context=fct_recode(context,stock="stock stock")) %>% 
                mutate(context = fct_relevel(context,"stock", after=0)) %>%
                mutate(Neggs_all=Neggs_start+Neggs_arrival) %>% 
                mutate(Neggs_all_scaled=scale(Neggs_all))
```


```{r}
if (file.exists(here("R_output", "model_dispersal1.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_dispersal1.Rdata"))
  } else {
mod_disp=brm(bf(Neggs_arrival|trials(Neggs_all)~context+Neggs_all_scaled+(1|Mix/IDgroup/IDpop)),
         data=data_disp,family=binomial,
         chains=4,iter=4000,
         prior=c(set_prior("normal(0,1.5)",class="Intercept"),
                 set_prior("normal(0,1)",class="b"),
                 set_prior("normal(0,1)",class="sd")),
         seed=42,control=list(adapt_delta=0.99), backend="cmdstanr"
)
  save(list = "mod_disp", file = here("R_output", "model_dispersal1.Rdata"))
}
```

think about adding the model minus Neggs_all_scaled and compare

```{r}
if (file.exists(here("R_output", "model_dispersal1_alt.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_dispersal1_alt.Rdata"))
  } else {
mod_disp_alt=brm(bf(Neggs_arrival|trials(Neggs_all)~context+(1|Mix/IDgroup/IDpop)),
         data=data_disp,family=binomial,
         chains=4,iter=4000,
         prior=c(set_prior("normal(0,1.5)",class="Intercept"),
                 set_prior("normal(0,1)",class="b"),
                 set_prior("normal(0,1)",class="sd")),
         seed=42,control=list(adapt_delta=0.99), backend="cmdstanr"
)
  save(list = "mod_disp_alt", file = here("R_output", "model_dispersal1_alt.Rdata"))
}
```


# Dispersal 2

```{r}

data_disp_dens<-raw_disp_dens %>% 
                mutate(IDgroup=ifelse(Generation==0,
                                      paste("Mix",Mix,"_stock",sep=""),
                                      paste("Mix",Mix,"_",Treatment,"_Rep",Replicate,"_GenerationFinal",sep="")
                                      )
                       )%>% 
                mutate(Location=fct_recode(factor(Location),edge="front")) %>% 
                mutate(Treatment=fct_recode(factor(Treatment),
                                            reference="control",
                                            `reduced connectivity`="restricted connectedness")) %>%
                mutate(IDpop=ifelse(Generation==0,
                                    IDgroup,
                                    paste(IDgroup,"_Location",Location,sep=""))) %>% 
                mutate(context=paste(Treatment,Location)) %>% 
                mutate(context=relevel(factor(context),"stock stock")) %>%
                mutate(context=fct_recode(context,stock="stock stock")) %>% 
                mutate(context = fct_relevel(context,"stock", after=0)) %>%
                mutate(Neggs_all=Neggs_start+Neggs_arrival) %>% 
                mutate(Neggs_all_scaled=scale(Neggs_all)) %>% 
                mutate(Density=fct_relevel(factor(Density),"high",after=Inf)) %>% 
                mutate(Density_centred = as.numeric(Density=="high") - mean(as.numeric(Density=="high")))
```


```{r}
if (file.exists(here("R_output", "model_dispersal2.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_dispersal2.Rdata"))
  } else {
mod_disp_dens=brm(bf(Neggs_arrival|trials(Neggs_all)~context*Density_centred+Neggs_all_scaled+(1|Mix/IDgroup/IDpop)),
         data=data_disp_dens,family=binomial,
         chains=4,iter=4000,
         prior=c(set_prior("normal(0,1.5)",class="Intercept"),
                 set_prior("normal(0,1)",class="b"),
                 set_prior("normal(0,1)",class="sd")),
         seed=42,control=list(adapt_delta=0.99),backend="cmdstanr"
)

  save(list = "mod_disp_dens", file = here("R_output", "model_dispersal2.Rdata"))
}
```

```{r}
if (file.exists(here("R_output", "model_dispersal2_alt.Rdata")))
# this if-else statement is avoid re-fitting a model when knitting Rmd file if there is already one existing in R_output
# to override, re-run the model and re-save manually by selecting relevant code lines then knit (or delete the Rdata object)
  {
    load(here("R_output", "model_dispersal2_alt.Rdata"))
  } else {
mod_disp_dens_alt=brm(bf(Neggs_arrival|trials(Neggs_all)~context*Density_centred+(1|Mix/IDgroup/IDpop)),
         data=data_disp_dens,family=binomial,
         chains=4,iter=4000,
         prior=c(set_prior("normal(0,1.5)",class="Intercept"),
                 set_prior("normal(0,1)",class="b"),
                 set_prior("normal(0,1)",class="sd")),
         seed=42,control=list(adapt_delta=0.99),backend="cmdstanr"
)

  save(list = "mod_disp_dens_alt", file = here("R_output", "model_dispersal2_alt.Rdata"))
}
```



```{r summary-model}
###prediction intervals around each point
ppc_ribbon(yrep=(predict(mod_disp_dens,summary=FALSE)),
           x=rank(predict(mod_disp_dens)[,1]),
           y=data_disp_dens$Neggs_arrival,
           prob = 0.5, prob_outer=0.95)
```


# Figures

## Body size

```{r figure1}
preds_size <- data_size %>% 
  select(context,Location,Treatment) %>% 
  mutate(Treatment=fct_relevel(factor(Treatment),"stock",after=0)) %>% 
  unique() %>% 
  add_fitted_draws(mod_size,re_formula = NA) %>% 
  ungroup() %>% 
  mutate(.value=.value* (sd(data_size$tibia,na.rm=TRUE))+ (mean(data_size$tibia,na.rm=TRUE))) %>% 
  select(.draw,.value,Treatment,Location,context)


ggplot(preds_size) +
  geom_jitter(data=data_size %>% 
                group_by(Location,Treatment,IDindiv) %>% 
                summarise(tibia=mean(tibia)),aes(x=Location,y=tibia),col="grey50",alpha=0.4)+
  stat_eye(aes(x=Location,y=.value),.width=c(0.01,0.95), slab_alpha=0.7)+
  scale_x_discrete("Experimental context")+
  scale_y_continuous("Mean tibia length (μm)")+
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  theme_bw()
```


## Short-term movement

## Fecundity

## Dispersal

```{r}

p1 <- data_disp %>% 
  mutate(Neggs_all_scaled = mean(Neggs_all_scaled),
         Neggs_all = 1) %>% 
  select(Location, Treatment, context, Neggs_all_scaled, Neggs_all) %>% 
  distinct() %>% 
  add_fitted_draws(mod_disp,re_formula=NA) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  ggplot()+
  geom_jitter(data=data_disp,
              aes(Location,Neggs_arrival/Neggs_all, size=Neggs_all),
              col="#d95f02",alpha=0.4)+  
  scale_size(range=c(1,4), guide=FALSE)+
  ggnewscale::new_scale("size")+
  stat_eye(aes(Location, .value),.width=c(0.01,0.95),fill="#d95f02", slab_alpha=0.7)+
  scale_x_discrete("")+
  scale_y_continuous("Effective dispersal rate")+
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  coord_cartesian(ylim=c(0,1))+
  theme_bw()


p2 <- data_disp_dens %>%  
  mutate(Neggs_all_scaled = mean(Neggs_all_scaled),
         Neggs_all = 1) %>% 
  select(Location, Treatment, context, Neggs_all_scaled, Neggs_all, Density, Density_centred) %>% 
  distinct() %>% 
  add_fitted_draws(mod_disp_dens,re_formula=NA) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% 
  ggplot()+
  geom_point(data=data_disp_dens,
             aes(Location,Neggs_arrival/Neggs_all, col=Density, size=Neggs_all),
             position=position_jitterdodge(dodge.width=1), alpha=0.4)+
  scale_size(range=c(1,4), guide=FALSE)+
  ggnewscale::new_scale("size")+
  stat_eye(aes(Location, .value,fill=Density), .width=c(0.01,0.95), position="dodge", slab_alpha=0.7)+
  scale_x_discrete("")+
  scale_y_continuous("Effective dispersal rate")+
  scale_fill_manual(values=c("#d95f02","#7570b3")) + 
  scale_colour_manual(values=c("#d95f02","#7570b3")) + 
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  coord_cartesian(ylim=c(0,1))+
  theme_bw()

p3 <- data_disp_dens %>%  
  mutate(Neggs_all_scaled = mean(Neggs_all_scaled),
         Neggs_all = 1) %>% 
  select(Location, Treatment, context, Neggs_all_scaled, Neggs_all, Density, Density_centred) %>% 
  distinct() %>% 
  add_fitted_draws(mod_disp_dens,re_formula=NA) %>% 
  ungroup() %>% 
  mutate(Treatment = fct_relevel(Treatment,"reference", after=Inf)) %>% 
  mutate(Treatment = fct_relevel(Treatment,"reduced connectivity", after=Inf)) %>% select(Location, Treatment, Density, .value, .draw) %>% 
  pivot_wider(names_from=Density,values_from=.value) %>% 
  mutate(diff=logit(high)-logit(low)) %>% 
  ggplot()+
  stat_eye(aes(Location, diff), .width=c(0.01,0.95),slab_alpha=0.7)+
  geom_hline(yintercept=0,lty=2)+
  scale_x_discrete("Experimental context")+
  scale_y_continuous("Net effect of density (logit scale)")+
  facet_grid(cols=vars(Treatment),scales="free_x",space="free_x")+
  coord_cartesian(ylim=c(-3,3))+
  theme_bw()


(p1/p2/p3) & plot_annotation(tag_levels = "A")

```

 easy to replace the models with their alt in chunk above to see inferences remain especially relative to DDD
